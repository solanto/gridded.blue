---
import publicClient from "../utilities/public-client"
import accumulateAuthorMedia, { whitelistFromSearchParams } from "../utilities/accumulate-author-media"
import uriToLink from "../utilities/uri-to-link"
import client from "../utilities/client"
import { Agent, type AppBskyFeedGetAuthorFeed } from "@atproto/api"
import { TokenRefreshError } from "@atproto/oauth-client-node"
import stateParams from "../utilities/state-params"
import { Image } from "astro:assets"
import * as SessionGetter from "../utilities/session-getter"
import Layout from "../layouts/Layout.astro"
import Header from "../components/Header.astro"
import { XRPCError } from "@atproto/xrpc"
import "@atcute/bluesky/lexicons"
import linkify from "linkify-html"
import { escapeHTML } from "astro/runtime/server/escape.js"


// const { profile } = Astro.params as {
// 	profile: string
// }

const profile = Astro.url.searchParams.get("profile")

if (!profile || Astro.url.searchParams.get("state")) {
	const maybeHandle = (await SessionGetter.profile(Astro.session))?.handle

	if (maybeHandle)
		Astro.url.searchParams.set("profile", maybeHandle)
	else Astro.url.searchParams.set("profile", "bsky.app")

	Astro.url.searchParams.delete("state")
	Astro.url.searchParams.delete("iss")
	Astro.url.searchParams.delete("code")

	return Astro.redirect(Astro.url)
}

const cursor = Astro.url.searchParams.get("cursor")

const whitelist = whitelistFromSearchParams(Astro.url.searchParams)

if (!Object.values(whitelist).some(value => value)) {
	Astro.url.searchParams.set("reply", "on")
	Astro.url.searchParams.set("unlabeled", "on")

	return Astro.redirect(Astro.url)
}

const { reply: _, ...labelWhitelist } = whitelist

if (!Object.values(labelWhitelist).some(value => value)) {
	Astro.url.searchParams.set("unlabeled", "on")

	return Astro.redirect(Astro.url)
}

let isProfilePublic = false

try {
	const {
		data: { labels }
	} = await publicClient.get(
		"app.bsky.actor.getProfile",
		{
			params: {
				actor: profile as string
			}
		}
	)

	isProfilePublic = Boolean(
		labels &&
			!labels.some(
				({ val }) =>
					val == "!no-unauthenticated"
			)
	)
} catch (error) {
	if ((error as any).status == 400) {
		console.log(
			"profile is not found; redirecting to /error/profile-not-found"
		)
		return Astro.rewrite("/error/profile-not-found")
	}
}

const identity = await SessionGetter.identity(Astro.session as any)

let getAuthorFeed =
	(params: AppBskyFeedGetAuthorFeed.QueryParams) => publicClient.get(
		"app.bsky.feed.getAuthorFeed",
		{ params }
	) as Promise<AppBskyFeedGetAuthorFeed.Response>

const loginPromptRedirect = Astro.redirect(
	"/login?" + stateParams(Astro.url.searchParams, profile)
)

if (identity)
	try {
		const agent = new Agent(
			await client.restore(identity.did)
		)

		getAuthorFeed = agent.getAuthorFeed
	} catch (error) {
		if (error instanceof TokenRefreshError)
			return loginPromptRedirect
	}
else if (!isProfilePublic) return loginPromptRedirect

let data

const accumulatorArguments = [
	getAuthorFeed,
	profile,
	36,
	whitelist,
	undefined
] satisfies Parameters<typeof accumulateAuthorMedia>

const {
	data: profileData
} = await publicClient.get(
	"app.bsky.actor.getProfile",
	{
		params: {
			actor: profile as string
		}
	}
)

try {
	data = await accumulateAuthorMedia(
		...accumulatorArguments,
		cursor ?? undefined
	)
} catch (error) {
	if (error instanceof XRPCError) {
		console.log({...error})

		data = await accumulateAuthorMedia(
			...accumulatorArguments
		)
	} else throw error
}

const { media, cursor: nextCursor } = data

const nextParams = new URLSearchParams(Astro.url.searchParams)

if (nextCursor) nextParams.set("cursor", nextCursor)
else nextParams.delete("cursor")
---

<Layout title=`${profileData.displayName} (@${profileData.handle})`>
	<Header identity={identity} />
	<main>
		<form
			action="/view"
			class="query-form"
			id="query-form"
		>
			<div class="toggles">
				<label
					for="reply-toggle"
					class="check-button"
				>
					<input
						type="checkbox"
						id="reply-toggle"
						name="reply"
						checked={whitelist.reply},
					/>
					replies
				</label>
				<fieldset class="labels" id="labels">
					<label
						for="unlabeled-toggle"
						class="check-button"
					>
						<input
							type="checkbox"
							id="unlabeled-toggle"
							name="unlabeled"
							checked={whitelist.unlabeled},
						/>
						unlabeled
					</label>
					<label
						for="suggestive-toggle"
						class="check-button important"
					>
						<input
							type="checkbox"
							id="suggestive-toggle"
							name="suggestive"
							checked={whitelist.suggestive}
						/>
						suggestive
					</label>
					<label
						for="nudity-toggle"
						class="check-button important"
					>
						<input
							type="checkbox"
							id="nudity-toggle"
							name="nudity"
							checked={whitelist.nudity}
						/>
						nudity
					</label>
					<label
						for="adult-toggle"
						class="check-button important"
					>
						<input
							type="checkbox"
							id="adult-toggle"
							name="adult"
							checked={whitelist.adult}
						/>
						adult
					</label>
				</fieldset>
			</div>
			<fieldset class="actor-section">
				<div class="actor-input">
					<input
						name="profile"
						type="search"
						value={profile}
						placeholder="username.bsky.social"
						autocorrect="off"
						autocapitalize="off"
						spellcheck="false"
						id="actor-input-box"
						list="actor-datalist"
					/>
					<datalist id="actor-datalist"></datalist>
				</div>
				<button type="submit" id="submit-button">view</button>
			</fieldset>
		</form>
		<section class="profile-info">
			<Image
				src={profileData.banner ?? "/images/blank.png"}
				alt=""
				height={300}
				inferSize={true}
				class="banner"
			/>
			<Image
				src={profileData.avatar ?? "/images/blank.png"}
				alt=""
				width={80}
				height={80}
				class="profile-icon"
			/>
			<h1>{profileData.displayName}</h1>
			<p class="bio" set:html={
				linkify(
					escapeHTML(profileData.description ?? "")
						.replace(/@([a-z0-9.]+)/gi, (_, fragment) => {
							const handle = fragment.replace(/\.$/, "")
							const maybePeriod = fragment.endsWith(".") ? "." : ""

							return `<a href="/view?profile=${handle}">@${handle}</a>${maybePeriod}`
						}),
					{ defaultProtocol: "https" }
				)
			} />
		</section>
		<details>
			<summary>share profile</summary>
			<p>
				Hit the <i class="share">share</i> button in your browser or copy and
				paste a link to this page for anyone to view this profile
				with the filters you've selected. ☺️
			</p>
		</details>
		<ol class="feed">
			{
				media.map(
					({ thumbnail, alt, uri, flag }) => (
						<li class={flag ?? null}>
							{
								flag == "multiple" ?
									<span class="flag">multiple images: </span>
									: flag == "video" ?
										<span class="flag">video: </span>
										: <></>
							}
							<a
								href={uriToLink(
									profile,
									uri
								)}
							>
								<Image
									src={thumbnail}
									alt={alt}
									height={300}
									inferSize={true}
								/>
							</a>
						</li>
					)
				)
			}
		</ol>
		{ nextCursor === null ? <></> : <a class="link-button" href={`/view?${nextParams}`}>next</a> }
	</main>
</Layout>

<script>
	import publicClient from "../utilities/public-client"
	import { scrollIntoView } from "seamless-scroll-polyfill"
	import type { IScrollConfig } from "seamless-scroll-polyfill/lib/scroll-step.d.ts"
	import { whitelistFromSearchParams } from "../utilities/accumulate-author-media"
	import { shallowEqualObjects } from "shallow-equal"
	// import { isValidHandle } from "@atproto/syntax"

	const actorDatalist = document.getElementById("actor-datalist")
	const actorInputBox = document.getElementById("actor-input-box") as HTMLInputElement | null
	const submitButton = document.getElementById("submit-button")
	const labelFieldset = document.getElementById("labels")
	const form = document.getElementById("query-form") as HTMLFormElement | null

	const params = new URLSearchParams(document.location.search)

	function addTransitionedListener(f: (event: TransitionEvent) => any) {
		submitButton?.addEventListener("transitionend",
			(event: TransitionEvent) => {
				f(event)
			},
			{ once: true }
		)
	}

	function updateSubmitButton(): void {
		if (form && submitButton && actorInputBox) {
			const defaultText =
				actorInputBox.value != params.get("profile") ||
				shallowEqualObjects(
					whitelistFromSearchParams(new FormData(form)),
					whitelistFromSearchParams(params)
				)

			if (defaultText) {
				if (submitButton.classList.contains("update")) {
					addTransitionedListener( () => {
						submitButton.innerText = "view"
						submitButton.classList.remove("transitioning")
					})

					submitButton.classList.add("transitioning")
					submitButton.classList.remove("update")
				}
			} else if (!submitButton.classList.contains("update")) {
				addTransitionedListener(() => {
					submitButton.innerText = "update"
					submitButton.classList.remove("transitioning")
				})

				submitButton.classList.add("update", "transitioning")
			}
		}
	}

	actorInputBox
		?.addEventListener("input",
			({ target }) => {
				updateSubmitButton()

				if ((target as HTMLInputElement).value.trim())
					publicClient.get(
						"app.bsky.actor.searchActorsTypeahead",
						{ params: { q: (target as HTMLInputElement).value } }
					).then(
						({ data: { actors } }) => {
							if (
								actors.length == 0
								|| !actors
									.map(({ handle }) => handle)
									.includes((target as HTMLInputElement).value)
							)
								submitButton?.setAttribute("disabled", "true")
							else submitButton?.removeAttribute("disabled")

							const options = actors.map(
								({ handle }) =>  {
									const option = document.createElement("option")
									option.setAttribute("value", handle)

									return option
								}
							)

							if (actorDatalist) {
								actorDatalist.textContent = ""

								for (const option of options)
									actorDatalist.appendChild(option)
							}
						}
					)
				else submitButton?.setAttribute("disabled", "true")
			}
		)

	const scrollOptions: ScrollIntoViewOptions = {
		block: "start",
		inline: "nearest",
		behavior: "smooth"
	}

	const scrollConfig: IScrollConfig = {
		duration: 300
	}

	actorInputBox
		?.addEventListener("focusin",
			() => scrollIntoView(actorInputBox, scrollOptions, scrollConfig)
		)

	actorInputBox
		?.addEventListener("focusout",
			() => scrollIntoView(document.body, scrollOptions, scrollConfig)
		)
	
	labelFieldset?.addEventListener("change", updateSubmitButton)
</script>